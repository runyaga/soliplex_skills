# Soliplex Skills Adapter - Implementation Plan

## Executive Summary

This document outlines the implementation plan for `soliplex_skills`, an adapter that integrates [pydantic-ai-skills](https://github.com/DougTrajano/pydantic-ai-skills) into the Soliplex framework. The adapter wraps the upstream Skills toolset to work with Soliplex's agent architecture and configuration system.

**Key Capability:** Agent Skills provide progressive disclosure of specialized capabilities - agents can discover, load, and execute domain-specific knowledge on-demand without saturating their context.

**Upstream Library:** Vendored at `vendor_pydantic_ai_skills/`

---

## Critical Design Decisions (From Gemini Reviews)

### Issue 1: Tool Argument Conflict (CRITICAL)

**Problem:** Soliplex's `ToolConfig.tool_requires` raises `ToolRequirementConflict` if a function requests both `tool_config` and `ctx`.

**Solution:** Use two patterns:
- **Pattern A (tool_config injection):** For `list_skills`, `load_skill` - no context needed
- **Pattern B (ctx.deps lookup):** For `read_skill_resource`, `run_skill_script` - need ctx for scripts

### Issue 2: Path Resolution (HIGH)

**Problem:** Relative paths in YAML must resolve against `_config_path.parent`, not CWD.

**Solution:** Override `from_yaml()` to resolve each directory path relative to config file location.

### Issue 3: Cache Key Hashable (HIGH)

**Problem:** Lists are not hashable for dictionary keys.

**Solution:** Store directories as comma-separated string (already hashable).

### Issue 4: System Prompt Injection (MEDIUM)

**Problem:** `SkillsToolset.get_instructions()` injects skill discovery into system prompt, but Soliplex doesn't auto-inject.

**Solution:** Document in room_config.yaml that system_prompt must include skill usage instructions.

---

## LLM Review Process

**IMPORTANT**: When running LLM reviews at phase gates:

1. **Use `mcp__gemini__read_files`** (NOT `ask_gemini`)
2. **Use model `gemini-3-pro-preview`**
3. **Include `PLAN.md`** so Gemini sees the phase objectives
4. **Include ALL source files touched in the phase**

### Review Prompt Template

```
This is Phase X.Y of soliplex_skills development: [Phase Title]

Refer to PLAN.md for phase objectives (included in file_paths).

Completed tasks this phase:
- [List what was done]

Please review for:
1. Any issues related to the phase objectives
2. Code quality issues
3. Security concerns
4. Thread-safety issues
5. Missing functionality or regressions

Report findings in this format:
| ID | File:Line | Issue | Severity |
```

---

## Project Structure

```
soliplex_skills/
├── src/
│   └── soliplex_skills/
│       ├── __init__.py           # Public exports
│       ├── config.py             # Soliplex ToolConfig integration
│       ├── adapter.py            # Core adapter wrapping upstream toolset
│       ├── tools.py              # Soliplex-compatible tool functions
│       └── exceptions.py         # Soliplex-specific exceptions
├── vendor_pydantic_ai_skills/    # Vendored upstream library
├── tests/
│   ├── unit/
│   │   ├── conftest.py
│   │   ├── test_config.py
│   │   ├── test_adapter.py
│   │   └── test_tools.py
│   └── functional/
│       ├── conftest.py
│       ├── test_skills/          # Test skill directories
│       └── test_skill_discovery.py
├── example/
│   ├── installation.yaml
│   ├── skills/
│   │   └── research-assistant/
│   │       └── SKILL.md
│   └── rooms/
│       └── skills-demo/
│           └── room_config.yaml
├── pyproject.toml
├── PLAN.md
└── README.md
```

---

## Phase 1: Foundation & Core Implementation

### 1.1 Configuration Module (`src/soliplex_skills/config.py`)

```python
"""Soliplex ToolConfig integration for Skills tools."""

from __future__ import annotations

import dataclasses
import pathlib
from typing import TYPE_CHECKING, Any

from pydantic_settings import BaseSettings, SettingsConfigDict
from soliplex.config import ToolConfig

if TYPE_CHECKING:
    from pydantic_ai_skills import SkillsToolset


class SkillsToolSettings(BaseSettings):
    """Environment-based configuration for Skills tools.

    Environment variables:
        SOLIPLEX_SKILLS_DIRECTORIES: Comma-separated skill directories
        SOLIPLEX_SKILLS_VALIDATE: Validate skill structure (default: True)
        SOLIPLEX_SKILLS_MAX_DEPTH: Max discovery depth (default: 3)
        SOLIPLEX_SKILLS_EXCLUDE_TOOLS: Comma-separated tools to exclude
    """

    model_config = SettingsConfigDict(env_prefix="SOLIPLEX_SKILLS_")

    directories: str = "./skills"
    validate: bool = True
    max_depth: int = 3
    exclude_tools: str = ""


def _get_env_settings() -> SkillsToolSettings:
    """Lazy-load environment settings."""
    return SkillsToolSettings()


@dataclasses.dataclass
class SkillsToolConfig(ToolConfig):
    """Base configuration for Skills tools.

    Inherits from soliplex.config.ToolConfig for full Soliplex integration.
    """

    directories: str = dataclasses.field(
        default_factory=lambda: _get_env_settings().directories
    )
    validate: bool = dataclasses.field(
        default_factory=lambda: _get_env_settings().validate
    )
    max_depth: int = dataclasses.field(
        default_factory=lambda: _get_env_settings().max_depth
    )
    exclude_tools: str = dataclasses.field(
        default_factory=lambda: _get_env_settings().exclude_tools
    )

    @classmethod
    def from_yaml(
        cls,
        installation_config: Any,
        config_path: pathlib.Path,
        config: dict[str, Any],
    ) -> SkillsToolConfig:
        """Create from Soliplex YAML configuration with path resolution."""
        env_settings = _get_env_settings()
        directories_raw = config.get("directories", env_settings.directories)

        # CRITICAL: Resolve paths relative to config file location
        resolved_directories = []
        if directories_raw:
            if isinstance(directories_raw, list):
                paths = directories_raw
            else:
                paths = [p.strip() for p in directories_raw.split(",") if p.strip()]

            for path_str in paths:
                path = pathlib.Path(path_str)
                if not path.is_absolute():
                    path = (config_path.parent / path).resolve()
                resolved_directories.append(str(path))

        config["directories"] = ",".join(resolved_directories)
        config.setdefault("validate", env_settings.validate)
        config.setdefault("max_depth", env_settings.max_depth)
        config.setdefault("exclude_tools", env_settings.exclude_tools)
        config["_installation_config"] = installation_config
        config["_config_path"] = config_path

        return cls(**config)

    def get_directories_list(self) -> list[str]:
        """Parse directories string into list."""
        if not self.directories:
            return []
        return [d.strip() for d in self.directories.split(",") if d.strip()]

    def get_exclude_tools_set(self) -> set[str]:
        """Parse exclude_tools string into set."""
        if not self.exclude_tools:
            return set()
        return {t.strip() for t in self.exclude_tools.split(",") if t.strip()}

    def create_toolset(self) -> SkillsToolset:
        """Create SkillsToolset from this configuration."""
        from pydantic_ai_skills import SkillsToolset

        return SkillsToolset(
            directories=self.get_directories_list(),
            validate=self.validate,
            max_depth=self.max_depth,
            exclude_tools=self.get_exclude_tools_set(),
        )


# Per-tool config classes for Soliplex registration
# TOOL_CONFIG_CLASSES_BY_TOOL_NAME uses klass.tool_name

@dataclasses.dataclass
class ListSkillsConfig(SkillsToolConfig):
    """Config for list_skills tool."""
    tool_name: str = "soliplex_skills.tools.list_skills"


@dataclasses.dataclass
class LoadSkillConfig(SkillsToolConfig):
    """Config for load_skill tool."""
    tool_name: str = "soliplex_skills.tools.load_skill"


@dataclasses.dataclass
class ReadSkillResourceConfig(SkillsToolConfig):
    """Config for read_skill_resource tool."""
    tool_name: str = "soliplex_skills.tools.read_skill_resource"


@dataclasses.dataclass
class RunSkillScriptConfig(SkillsToolConfig):
    """Config for run_skill_script tool."""
    tool_name: str = "soliplex_skills.tools.run_skill_script"
```

### 1.2 Adapter Module (`src/soliplex_skills/adapter.py`)

```python
"""Core adapter bridging pydantic-ai-skills with Soliplex."""

from __future__ import annotations

import asyncio
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pydantic_ai_skills import SkillsToolset
    from soliplex_skills.config import SkillsToolConfig

# Module-level cache: hashable key -> toolset
_toolset_cache: dict[tuple, SkillsToolset] = {}
_cache_lock = asyncio.Lock()


async def _get_toolset(config: SkillsToolConfig) -> SkillsToolset:
    """Get or create SkillsToolset from config.

    Thread-safe caching supports multiple concurrent configurations.
    Key is tuple of primitive types (all hashable).
    """
    # All attributes are primitive types (str, int, bool) - hashable
    key = (
        config.directories,
        config.validate,
        config.max_depth,
        config.exclude_tools,
    )

    if key in _toolset_cache:
        return _toolset_cache[key]

    async with _cache_lock:
        if key in _toolset_cache:
            return _toolset_cache[key]

        toolset = config.create_toolset()
        _toolset_cache[key] = toolset
        return toolset


def close_all() -> None:
    """Clear all cached toolsets."""
    _toolset_cache.clear()


class SoliplexSkillsAdapter:
    """Adapter wrapping pydantic-ai-skills for Soliplex."""

    def __init__(self, toolset: SkillsToolset):
        self._toolset = toolset

    @property
    def skills(self) -> dict[str, Any]:
        """Get available skills."""
        return self._toolset.skills

    async def list_skills(self) -> dict[str, str]:
        """List all available skills with descriptions."""
        return {
            name: skill.description
            for name, skill in self._toolset.skills.items()
        }

    async def load_skill(self, skill_name: str) -> str:
        """Load complete instructions for a skill."""
        from pydantic_ai_skills import SkillNotFoundError

        if skill_name not in self._toolset.skills:
            available = ", ".join(sorted(self._toolset.skills.keys())) or "none"
            raise SkillNotFoundError(
                f"Skill '{skill_name}' not found. Available: {available}"
            )

        skill = self._toolset.skills[skill_name]

        resources_list = []
        if skill.resources:
            for res in skill.resources:
                resources_list.append(f'<resource name="{res.name}" />')

        scripts_list = []
        if skill.scripts:
            for scr in skill.scripts:
                scripts_list.append(f'<script name="{scr.name}" />')

        return f"""<skill>
<name>{skill.name}</name>
<description>{skill.description}</description>
<uri>{skill.uri or 'N/A'}</uri>

<resources>
{chr(10).join(resources_list) if resources_list else '<!-- No resources -->'}
</resources>

<scripts>
{chr(10).join(scripts_list) if scripts_list else '<!-- No scripts -->'}
</scripts>

<instructions>
{skill.content}
</instructions>
</skill>
"""

    async def read_skill_resource(
        self,
        skill_name: str,
        resource_name: str,
        args: dict[str, Any] | None = None,
        ctx: Any = None,
    ) -> str:
        """Read a skill resource."""
        from pydantic_ai_skills import SkillNotFoundError, SkillResourceNotFoundError

        if skill_name not in self._toolset.skills:
            raise SkillNotFoundError(f"Skill '{skill_name}' not found.")

        skill = self._toolset.skills[skill_name]

        resource = None
        if skill.resources:
            for r in skill.resources:
                if r.name == resource_name:
                    resource = r
                    break

        if resource is None:
            available = [r.name for r in skill.resources] if skill.resources else []
            raise SkillResourceNotFoundError(
                f"Resource '{resource_name}' not found in skill "
                f"'{skill_name}'. Available: {available}"
            )

        return await resource.load(ctx=ctx, args=args)

    async def run_skill_script(
        self,
        skill_name: str,
        script_name: str,
        args: dict[str, Any] | None = None,
        ctx: Any = None,
    ) -> str:
        """Execute a skill script."""
        from pydantic_ai_skills import SkillNotFoundError, SkillResourceNotFoundError

        if skill_name not in self._toolset.skills:
            raise SkillNotFoundError(f"Skill '{skill_name}' not found.")

        skill = self._toolset.skills[skill_name]

        script = None
        if skill.scripts:
            for s in skill.scripts:
                if s.name == script_name:
                    script = s
                    break

        if script is None:
            available = [s.name for s in skill.scripts] if skill.scripts else []
            raise SkillResourceNotFoundError(
                f"Script '{script_name}' not found in skill "
                f"'{skill_name}'. Available: {available}"
            )

        return await script.run(ctx=ctx, args=args)
```

### 1.3 Tools Module (`src/soliplex_skills/tools.py`)

```python
"""Soliplex-compatible tool functions.

Two patterns used to avoid ToolRequirementConflict:
- Pattern A: tool_config injection (list_skills, load_skill)
- Pattern B: ctx.deps lookup (read_skill_resource, run_skill_script)
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

from pydantic_ai import RunContext

from soliplex_skills.adapter import SoliplexSkillsAdapter, _get_toolset
from soliplex_skills.config import SkillsToolConfig

if TYPE_CHECKING:
    from soliplex.agents import AgentDependencies


async def _get_adapter(config: SkillsToolConfig) -> SoliplexSkillsAdapter:
    """Get adapter from config."""
    toolset = await _get_toolset(config)
    return SoliplexSkillsAdapter(toolset)


def _get_config_from_ctx(
    ctx: RunContext[AgentDependencies],
    kind: str
) -> SkillsToolConfig:
    """Retrieve tool config from context dependencies.

    Used when tools require ctx and cannot use direct tool_config injection.
    """
    if not ctx.deps.tool_configs:
        raise ValueError("No tool configs found in context dependencies")

    config = ctx.deps.tool_configs.get(kind)
    if not config:
        raise ValueError(f"Tool config for kind '{kind}' not found")

    if not isinstance(config, SkillsToolConfig):
        raise TypeError(
            f"Config for '{kind}' is {type(config)}, expected SkillsToolConfig"
        )

    return config


# --- Pattern A: Tool Config Injection (No Context Needed) ---

async def list_skills(tool_config: SkillsToolConfig) -> dict[str, str]:
    """List all available skills.

    Returns:
        Dictionary mapping skill names to their descriptions.
        Empty dictionary if no skills are available.
    """
    adapter = await _get_adapter(tool_config)
    return await adapter.list_skills()


async def load_skill(
    tool_config: SkillsToolConfig,
    skill_name: str,
) -> str:
    """Load complete instructions for a specific skill.

    Args:
        skill_name: Exact name from your available skills list.
            Must match exactly (e.g., "data-analysis" not "data analysis").

    Returns:
        Structured documentation containing skill instructions,
        available resources, and scripts.
    """
    adapter = await _get_adapter(tool_config)
    return await adapter.load_skill(skill_name)


# --- Pattern B: Context Injection (Config Lookup) ---

async def read_skill_resource(
    ctx: RunContext[AgentDependencies],
    skill_name: str,
    resource_name: str,
    args: dict[str, Any] | None = None,
) -> str:
    """Read a skill resource file or invoke callable resource.

    Args:
        skill_name: Name of the skill containing the resource.
        resource_name: Exact name of the resource as listed in the skill.
        args: Arguments for callable resources (optional for static files).

    Returns:
        The resource content as a string.
    """
    tool_config = _get_config_from_ctx(ctx, "read_skill_resource")
    adapter = await _get_adapter(tool_config)
    return await adapter.read_skill_resource(
        skill_name, resource_name, args=args, ctx=ctx
    )


async def run_skill_script(
    ctx: RunContext[AgentDependencies],
    skill_name: str,
    script_name: str,
    args: dict[str, Any] | None = None,
) -> str:
    """Execute a skill script.

    Args:
        skill_name: Name of the skill containing the script.
        script_name: Exact name of the script as listed in the skill.
        args: Arguments required by the script.

    Returns:
        Script execution output.
    """
    tool_config = _get_config_from_ctx(ctx, "run_skill_script")
    adapter = await _get_adapter(tool_config)
    return await adapter.run_skill_script(
        skill_name, script_name, args=args, ctx=ctx
    )
```

### 1.4 Exceptions Module (`src/soliplex_skills/exceptions.py`)

```python
"""Soliplex-specific exceptions for Skills adapter."""

from __future__ import annotations


class SoliplexSkillsError(Exception):
    """Base exception for soliplex_skills errors."""


class SkillsConfigurationError(SoliplexSkillsError):
    """Configuration-related errors."""


class SkillsContextError(SoliplexSkillsError):
    """Context/dependencies lookup errors."""
```

### 1.5 Init Module (`src/soliplex_skills/__init__.py`)

```python
"""Soliplex Skills Adapter.

Integrates pydantic-ai-skills into the Soliplex framework.
"""

from __future__ import annotations

import pathlib
import sys

# Ensure vendored library is importable
_VENDOR_PATH = pathlib.Path(__file__).parents[2] / "vendor_pydantic_ai_skills"
if _VENDOR_PATH.exists() and str(_VENDOR_PATH) not in sys.path:
    sys.path.insert(0, str(_VENDOR_PATH))

from importlib.metadata import version

from soliplex_skills.config import (
    ListSkillsConfig,
    LoadSkillConfig,
    ReadSkillResourceConfig,
    RunSkillScriptConfig,
    SkillsToolConfig,
    SkillsToolSettings,
)
from soliplex_skills.exceptions import (
    SkillsConfigurationError,
    SkillsContextError,
    SoliplexSkillsError,
)
from soliplex_skills.tools import (
    list_skills,
    load_skill,
    read_skill_resource,
    run_skill_script,
)

__all__ = [
    # Configuration
    "SkillsToolConfig",
    "SkillsToolSettings",
    "ListSkillsConfig",
    "LoadSkillConfig",
    "ReadSkillResourceConfig",
    "RunSkillScriptConfig",
    # Exceptions
    "SoliplexSkillsError",
    "SkillsConfigurationError",
    "SkillsContextError",
    # Tools
    "list_skills",
    "load_skill",
    "read_skill_resource",
    "run_skill_script",
]

__version__ = version("soliplex-skills")
```

---

## Phase 2: Example Configuration Files

### 2.1 Installation Registration (`example/installation.yaml`)

```yaml
meta:
  tool_configs:
    - soliplex_skills.config.ListSkillsConfig
    - soliplex_skills.config.LoadSkillConfig
    - soliplex_skills.config.ReadSkillResourceConfig
    - soliplex_skills.config.RunSkillScriptConfig
```

### 2.2 Room Configuration (`example/rooms/skills-demo/room_config.yaml`)

Based on real Soliplex pattern from `~/dev/soliplex/example/rooms/haiku/room_config.yaml`:

```yaml
id: skills-demo
name: Skills Demo Assistant
description: Demonstrates skills integration with Soliplex

suggestions:
  - "What skills are available?"
  - "Load the research-assistant skill"

agent:
  template_id: default_chat  # Use installation's agent template
  system_prompt: ./prompt.txt  # File with skill usage instructions

tools:
  - tool_name: soliplex_skills.tools.list_skills
    directories: ../../skills  # Resolved relative to this file

  - tool_name: soliplex_skills.tools.load_skill
    directories: ../../skills

  - tool_name: soliplex_skills.tools.read_skill_resource
    directories: ../../skills

  - tool_name: soliplex_skills.tools.run_skill_script
    directories: ../../skills
```

### 2.2.1 System Prompt File (`example/rooms/skills-demo/prompt.txt`)

```text
You are a helpful assistant with access to specialized skills.

SKILL USAGE INSTRUCTIONS:
1. Use `list_skills` to see what capabilities are available.
2. When a task matches a skill, use `load_skill` to get instructions.
3. Follow the skill's specific workflow.
4. Use `read_skill_resource` for additional context files.
5. Use `run_skill_script` for executable actions.

Always check `list_skills` first if asked about capabilities.
```

### 2.3 Example Skill (`example/skills/research-assistant/SKILL.md`)

```markdown
---
name: research-assistant
description: Helps with research tasks and finding information
---

# Research Assistant Skill

Use this skill for research tasks including:
- Finding relevant papers and articles
- Summarizing information
- Organizing research notes

## Workflow

1. Use the `REFERENCES.md` resource for citation formatting
2. Run the `search.py` script to find relevant papers
```

---

## Phase 3: pyproject.toml

```toml
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "soliplex-skills"
version = "0.1.0dev0"
description = "Soliplex adapter for pydantic-ai-skills"
authors = [{ name = "runyaga", email = "runyaga@gmail.com" }]
readme = "README.md"
requires-python = ">=3.12"
classifiers = [
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "License :: OSI Approved :: MIT License",
]
dependencies = [
    "pydantic >= 2.0.0",
    "pydantic-settings >= 2.0.0",
    "pydantic-ai >= 0.5.0",
]

[project.optional-dependencies]
soliplex = ["soliplex"]

[dependency-groups]
dev = [
    "pytest >= 8.0.0",
    "pytest-cov >= 4.0.0",
    "pytest-asyncio >= 0.23.0",
    "coverage >= 7.0.0",
    "ruff >= 0.4.0",
    "soliplex",
]

[tool.pytest.ini_options]
pythonpath = "src"
python_files = "test_*.py"
testpaths = ["tests/unit"]
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
addopts = "--cov=soliplex_skills --cov-branch --cov-fail-under=80"

[tool.coverage.run]
source = ["src/soliplex_skills"]

[tool.coverage.report]
show_missing = true

[tool.ruff]
line-length = 79
target-version = "py312"

[tool.ruff.lint]
select = ["F", "E", "B", "UP", "I", "TRY", "PT", "SIM", "RUF"]

[tool.ruff.lint.isort]
force-single-line = true
```

---

## Phase 4: Testing Strategy

### 4.1 Test Fixtures

```python
# tests/unit/conftest.py
import pathlib
import pytest
from unittest.mock import MagicMock

@pytest.fixture
def mock_installation_config():
    return MagicMock()

@pytest.fixture
def config_path(tmp_path):
    return tmp_path / "room_config.yaml"

@pytest.fixture
def mock_agent_deps():
    """Mock AgentDependencies for ctx-based tools."""
    deps = MagicMock()
    deps.tool_configs = {}
    return deps
```

### 4.2 Key Test Cases

1. **Path Resolution Test**: Verify relative paths resolve against config_path.parent
2. **Cache Key Test**: Verify same config produces same toolset instance
3. **Tool Pattern A Test**: list_skills/load_skill with tool_config injection
4. **Tool Pattern B Test**: read_skill_resource/run_skill_script with ctx.deps lookup
5. **Error Handling Test**: SkillNotFoundError, config lookup failures

---

## Progress Tracking

### Phase 1: Foundation
- [ ] Create project directory structure
- [ ] Create pyproject.toml
- [ ] Implement exceptions.py
- [ ] Implement config.py with path resolution
- [ ] Implement adapter.py with caching
- [ ] Implement tools.py with both patterns
- [ ] Create __init__.py with exports
- [ ] Write unit tests
- [ ] Run ruff and fix issues
- [ ] Verify >=80% coverage
- [ ] **LLM Review** - Gemini pro3

### Phase 2: Functional Tests
- [ ] Create test skill directories
- [ ] Test all 4 tools
- [ ] Test path resolution from room config
- [ ] Test ctx.deps lookup pattern
- [ ] Increase coverage to >=90%
- [ ] **LLM Review** - Gemini pro3

### Phase 3: Integration
- [ ] Create example/installation.yaml
- [ ] Create example room config
- [ ] Create example skill
- [ ] Test with actual Soliplex
- [ ] **LLM Review** - Gemini pro3

### Phase 4: Polish
- [ ] Complete README.md
- [ ] Final ruff pass
- [ ] Coverage >=95%
- [ ] **Final LLM Review** - Gemini pro3
- [ ] Tag release

---

## Summary

| Phase | Key Deliverables | Gate Criteria |
|-------|-----------------|---------------|
| 1. Foundation | config, adapter, tools, tests | >=80% coverage, ruff clean |
| 2. Functional | integration tests, skill discovery | >=90% coverage |
| 3. Integration | example configs, Soliplex test | working room |
| 4. Polish | docs, CI, release | >=95% coverage |

### Critical Implementation Notes

1. **Two Tool Patterns**: Use tool_config injection for simple tools, ctx.deps lookup for tools needing context
2. **Path Resolution**: Always resolve in from_yaml against config_path.parent
3. **Cache Keys**: Use primitive types (str, int, bool) - all hashable
4. **System Prompt**: Document that users must include skill instructions in system_prompt
5. **Vendored Library**: pydantic-ai-skills at vendor_pydantic_ai_skills/
